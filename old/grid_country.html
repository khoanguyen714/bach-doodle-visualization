<html>
  <head>
    <title>grid</title>
    <meta charset="utf-8">
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@magenta/music@1.8.0"></script>
    <script src="common.js"></script>
    <link href="style.css" rel="stylesheet">
  </head>
  <body>
    <h1 id="h1"></h1>
    <p>
      Explanation: Each row is a sequence of length 14. Any sequences that have that as
      a suffix are added to that row. Any sequences that are shorter, but are the beginning
      of that row are added to that row. Rows are sorted by these total values.
    </p>
    slow to load, hover to inspect, click to play
    <div id="legend"></div>
    <svg id="svg"></svg>
    <div class="tooltip" id="tooltip" hidden>
      <span id="seqText"></span>: <span hidden><b id="valueText" ></b> times</span><br>
      <svg id="visualizer"></svg>
    </div>
  </body>
  <script>
    const search = window.location.search.split('=');
    const country = search.length > 0 ? search[1] : 'us';
    h1.textContent = document.title = country + ' ' + isoCountries[country.toUpperCase()];
    
    d3.json('/data/top_per_country.json').then((json) => {
      loadAllSamples();
      showData(json[country]);
    });
    
    const FIXED_LENGTH = 14;
    ZOOM_OPACITY = 0.7;
    
    function showData(tree) {
      const data = [];
      flatten(tree, data, '');
      data.sort((a,b) => b.value - a.value)
      
      data.forEach(d => {
        d.deltas = d.str.trim().split(' ')
        d.fixedChunk = d.deltas.slice(0, FIXED_LENGTH)
      });
      
      //runSomeStats(data);
      
      // This contains a sequence of 16 notes, and an array of all the sequences that
      // have the key as a prefix, 
      const by16 = d3.nest()
        .key(d => d.fixedChunk.join(' '))
        .entries(data.filter(d => d.fixedChunk.length == FIXED_LENGTH))
      
      // Now also add any subsequences that fit in these fixed chunks.
      let count = 0;
      data.forEach(d => {
        // Could this be a substring?
        if (d.deltas.length < FIXED_LENGTH) {
          for (let i = 0; i < by16.length; i++) {
            if (by16[i].key.indexOf(d.str) === 0) {
              count++;
              by16[i].values.push(d);
              break
            }
          }
        }
      });
      console.log('added', count);
      
      // Sum up the children's values into the parent, and sort.
      by16.forEach((d) => {
        let value = 0;
        let longestDeltas = [];
        let longestTiming = [];
        d.values.forEach((c) => {
          value += c.value;
          // Also find out the longest sequence, so that we can hear it.
          if (c.deltas.length > longestDeltas.length) {
            longestDeltas = c.deltas; 
            longestTiming = c.timing;
          }
        });
        d.value = value;
        d.timing = longestTiming;
        d.deltas = longestDeltas.map(d => parseInt(d));
        d.displayDeltas = d.deltas.slice(0, FIXED_LENGTH);
      });
      by16.sort((a,b) => b.value - a.value);
      
      // Calculate the y0 and y1 for the bars.
      let prevY = 0;
      by16.forEach((d) => {
        d.y0 = prevY;
        d.y1 = prevY + d.value;
        prevY = d.y1;
      });
      
      const height = window.innerHeight - 200;
      const width = window.innerWidth - 100;
      const svg = d3.select('#svg')
          .style('width', '100%')
          .style('height', 'auto')
      
      const xScale = d3.scaleLinear().domain([0, FIXED_LENGTH]).range([0, width]);
      const yScale = d3.scaleLinear().domain([0, prevY]).range([0, height]);
      
      const row = svg
        .selectAll('g')
        .data(by16)
        .enter()
        .append('g')
        .attr('transform', (d) => `translate(0, ${yScale(d.y0)})`)
        .attr('height', (d) => yScale(d.y1) - yScale(d.y0))
        .on('click', handleClick)
        .on('mouseover', function (d, i, x) {  // need to maintain the this, sigh.
          showTooltip(d,i,x, this);
          // Fade all the other rows and highlight this one.
          this.childNodes.forEach(n => d3.select(n).style('fill-opacity', 1));
          
        })
        .on('mouseout', function (d,i) {
          hideTooltip();
          svg.selectAll('rect').style('fill-opacity', ZOOM_OPACITY);
        });

      row.selectAll('rect')
        .data((d) => d.displayDeltas)
        .enter().append('rect')
        .attr('x', (d, i) => xScale(i))
        .attr('width', (d, i) => xScale(i+1) - xScale(i))
        .attr('height', (d, i, nodes) => d3.select(nodes[0].parentNode).attr('height'))
        .style('fill', (d) => color(parseInt(d)))
        .style('fill-opacity', ZOOM_OPACITY)
        .style('stroke', 'white')
        .style('stroke-width', 1)
    
      const el = document.getElementById('svg');
      const box = el.getBBox();
      el.setAttribute('viewBox', `${box.x} ${box.y} ${box.width} ${box.height}`);
    }
    
    function flatten(node, acc, prevStr) {
      const str = prevStr + (node.name == 'root' ? '' : node.name + ' ')
      if (node.value) {
        acc.push({str, value: node.value, timing: node.timing})
      }
      if (node.children) {
        node.children.forEach(d => flatten(d, acc, str))
      }
    }
    
    function runSomeStats(data) {
      let lessThan16 = 0;  // This ends up being 1811/1966
      let totalLength = 0;  // This ends up being 6.84
      let lengthHistogram = {};  // peaks at 4 (1348)
      data.forEach(d => {
        const len = d.deltas.length;
        totalLength += len;
        if (len < 16) {
          lessThan16++
        }
        if (lengthHistogram[len]) {
          lengthHistogram[len]++;
        } else {
          lengthHistogram[len] = 1
        }
      });
      
      console.log('#sequences with < 16 notes', lessThan16, 'out of', data.length);
      console.log('avg sequence length', totalLength/data.length);
      console.log('length histogram', lengthHistogram);
    }
  </script>
</html>


