<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Overall repeated melodies</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="description" content="Exploring the Bach Doodle dataset">
    <link rel="preconnect" href="https://storage.googleapis.com">
    <link href="style.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Work+Sans:400,700&display=swap" rel="stylesheet">
    <style>
      input[type=number] {
        border: none;
        font-size: inherit;
        font-family: inherit;
        font-weight: inherit;
        background: transparent;
        box-shadow: none;
        border-bottom: 4px solid black;
        width: 100px;
        text-align: center;
      }
      #mels .line {
        stroke-width: 1.5;
        stroke-linejoin: round;
        stroke-linecap: round;
        //mix-blend-mode: multiply;
      }
    </style>
  </head>
  <body>
    <header>
      <div class="horizontal">
        <button class="menu-btn" aria-label="nav drawer button" onclick="document.body.classList.toggle('drawer-opened')">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
        </button>
        <a href="index.html">Bach Doodle Dataset</a>
      </div>

      <div class="menu">
        <div class="hide-from-toolbar">
          <a href="dataset.html">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 14H4V6h16v12zM6 10h2v2H6zm0 4h8v2H6zm10 0h2v2h-2zm-6-4h8v2h-8z"/></svg>       Explore the dataset
          </a>
          <a href="overall.html">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M12 7.13l.97 2.29.47 1.11 1.2.1 2.47.21-1.88 1.63-.91.79.27 1.18.56 2.41-2.12-1.28-1.03-.64-1.03.62-2.12 1.28.56-2.41.27-1.18-.91-.79-1.88-1.63 2.47-.21 1.2-.1.47-1.11.97-2.27M12 2L9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2z"/></svg>
            Explore the top overall melodies
          </a>
          <a href="world.html">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zm6.93 6h-2.95c-.32-1.25-.78-2.45-1.38-3.56 1.84.63 3.37 1.91 4.33 3.56zM12 4.04c.83 1.2 1.48 2.53 1.91 3.96h-3.82c.43-1.43 1.08-2.76 1.91-3.96zM4.26 14C4.1 13.36 4 12.69 4 12s.1-1.36.26-2h3.38c-.08.66-.14 1.32-.14 2 0 .68.06 1.34.14 2H4.26zm.82 2h2.95c.32 1.25.78 2.45 1.38 3.56-1.84-.63-3.37-1.9-4.33-3.56zm2.95-8H5.08c.96-1.66 2.49-2.93 4.33-3.56C8.81 5.55 8.35 6.75 8.03 8zM12 19.96c-.83-1.2-1.48-2.53-1.91-3.96h3.82c-.43 1.43-1.08 2.76-1.91 3.96zM14.34 14H9.66c-.09-.66-.16-1.32-.16-2 0-.68.07-1.35.16-2h4.68c.09.65.16 1.32.16 2 0 .68-.07 1.34-.16 2zm.25 5.56c.6-1.11 1.06-2.31 1.38-3.56h2.95c-.96 1.65-2.49 2.93-4.33 3.56zM16.36 14c.08-.66.14-1.32.14-2 0-.68-.06-1.34-.14-2h3.38c.16.64.26 1.31.26 2s-.1 1.36-.26 2h-3.38z"/></svg>
            Explore melodies around the world
          </a>
          <a href="unique.html">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M22 11h-4.17l3.24-3.24-1.41-1.42L15 11h-2V9l4.66-4.66-1.42-1.41L13 6.17V2h-2v4.17L7.76 2.93 6.34 4.34 11 9v2H9L4.34 6.34 2.93 7.76 6.17 11H2v2h4.17l-3.24 3.24 1.41 1.42L9 13h2v2l-4.66 4.66 1.42 1.41L11 17.83V22h2v-4.17l3.24 3.24 1.42-1.41L13 15v-2h2l4.66 4.66 1.41-1.42L17.83 13H22z"/><path fill="none" d="M0 0h24v24H0z"/></svg>
            Explore the most unique compositions
          </a>
        </div>
          <a href="https://magenta.tensorflow.org/datasets" target="_blank">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"/></svg>
            Get the data
          </a>
          <a href="https://www.google.com/doodles/celebrating-johann-sebastian-bach" target="_blank">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M15 6H3v2h12V6zm0 4H3v2h12v-2zM3 16h8v-2H3v2zM17 6v8.18c-.31-.11-.65-.18-1-.18-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3V8h3V6h-5z"/></svg>
            Play the game
          </a>
          <a target="_blank" href="https://twitter.com/intent/tweet?hashtags=madewithmagenta&text=What%20do%2024%20million%20melodies%20composed%20with%20the%20Bach%20Doodle%20look%20like%3F%20https%3A%2F%2Fmagenta.tensorflow.org%2Fdatasets">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"/></svg>
            Share
          </a>
        </div>
      </div>
    </header>

    <section>
      <h1>What did the doodlers compose?</h1>
      <p class="trivia">
        There were over <b>24 million</b> total sequences entered in the dataset,
        and we heard a lot of popular favourites! The doodle's presets
        ("Twinkle Twinkle Little Star", "Mary Had a Little Lamb" and
        Bach's "Tocatta and Fugue in D minor") were by far the most repeated
        sequences, but we found some surprising runner ups. Explore them below!
      </p>
     </section>

    <div class="center">
      <h2>Top 2000 melodies</h2>
      <svg id="mels"></svg>
    </div>
    <div class="center">
      <h2>All melodies that start on a delta = <input type="number" value="0" id="deltaInput"></h2>
      <svg class="force" id="svg"></svg>
    </div>
    <section>
      <p>
        <span id="overallHelp" hidden>
        <span class="accent secondary outline">Move</span> any of the labels out of the way.</span>
        <span class="accent secondary outline">Hover</span> over any of the cells to see a quick preview
        of the melody. <span class="accent secondary outline">Click</span> on a cell to see
        more details about it, listen to it, or see what the harmonization could have been.
        <span id="unseenHelp" hidden>The <span class="accent secondary">yellow</span> cells represent
        melodies that were not in the top in any other country.</span>
      </p>
      <p id="mobileScreen" class="small" hidden>Your screen size is quite small, so we've
        hidden the labels for the most recognizable melodies. You can re-enable
        them with this checkbox, but at your own risk: they're not
        super usable on mobile, unfortunately. <input type="checkbox" id="forceLabels">
      </p>
    </section>
    <div class="tooltip" id="tooltip" hidden>
      <div>
        Composed in <b id="sessionsText"></b> sessions and harmonized a total of <b id="valueText"></b> times.
      </div>
      <div class="viz">
        <svg id="visualizer"></svg>
      </div>
      <div class="small status" hidden>Harmonizing takes a couple of seconds...please wait.</div>
      <div class="actions horizontal">
        <div>
          <button class="accent secondary" onclick="playMelody()" id="btnPlay">play</button>
          <button class="accent secondary" onclick="harmonize(event)" id="btnHarmonize">harmonize</button>
        </div>
        <button class="accent secondary" onclick="closeTooltip()">close</button>
      </div>
      <br>
      <div class="small hint">Click to expand and listen. Shift click to zoom in to the melodies starting on this note.
        <span id="whiteCircleHint" hidden>Click on the white circle in the middle to go back.</span>
      </div>
      <div id="melodyTweet"></div>
    </div>
  </body>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-annotation/2.3.2/d3-annotation.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@magenta/music@1.8.0"></script>
  <script src="common.js"></script>
  <script src="viz.js"></script>
  <script>
    let allData, allLabels;
    let mapDeltaToDataIndex = {};

    // Don't redraw on resize on mobile since that's probably a zoom event.
    if (('ontouchstart' in window) === false) {
      window.addEventListener('resize', update);
    }

    deltaInput.addEventListener('change', () => {
      update(true);
    });

    d3.json('data/top_overall_flat.json').then((json) => {
      allData = json;

      for (let i = 0; i < allData.length; i++) {
        const delta = allData[i][0].str.split(' ')[0];
        mapDeltaToDataIndex[delta] = i;
      }
      update();
    });

    function update(forceGraphOnly = false) {
      const n = mapDeltaToDataIndex[deltaInput.value];
      if (n !== undefined) {
        console.log(allData[n].length, allData[n][0].str)
        showData(flattenData(allData[n]));
      } else {
        console.log('don\'t have anything for delta', deltaInput.value);
      }
      if (!forceGraphOnly) {
        showMelodies(allData);
      }
    }

    function showMelodies(data) {
      const width = window.innerWidth - 100;
      const height = 300;

      const median = 370;
      const xscale = d3.scaleSymlog().constant(10).domain([150,20000]).range([20, width])
      const yscale = d3.scaleLinear().domain([3, 32]).range([height-20, 20])

      const svg = d3.select('#mels');
      svg.attr('width', width)
         .attr('height', height);
      const g = svg.append('g');

      // x-axis.
      svg.append('g')
        .attr('transform', `translate(0, ${height})`)
        .call(d3.axisBottom(xscale));
      svg.append('text')
        .attr('transform', `translate(${width/2}, ${height-40})`)
        .style('text-anchor', 'middle')
        .text('Harmonizations');

      svg.append('g')
          .call(d3.axisRight(yscale));
      svg.append('text')
          .attr('transform', `translate(10,10) rotate(-90)`)
          .attr('y', 20)
          .attr('x', 0 - (height / 2))
          .attr('dy', '1em')
          .style('text-anchor', 'middle')
          .text('Melody Length');

      const line = d3.line()
        .x((d,i) => xscale(i))
        .y(yscale(median))// >= median ? +d.count : -d.count))

      // Append the median line.
      const medianData =new Array(315).fill({count:median});
      g.append('path').datum(medianData)
          .attr('class', 'line')
          .attr('d', line)
          .attr('stroke', 'black')
          .attr('stroke-width', '10px')
          .attr('fill', 'black');

     for (let n = 0; n < allData.length; n++) {
        const subset = allData[n];
        const delta = subset[0].str.split(' ')[0];
        g.append('g').selectAll('.dot')
          .data(subset)
          .enter().append('circle')
          .attr('class', 'dot')
          .attr('r', 3)
          .attr('cx', (d,i) => xscale(d.count))
          .attr('cy', (d) => yscale(d.timing.length))
          .style('fill', color(parseInt(delta)))
          .style('fill-opacity', 0.6)
          .on('click', function (d,i) {
            handleHackyClick({data:d}, 'mels');
          })
          .on('mouseover', function (d,i) {
            const el = d3.select(this);
            el.attr('r', 10);
            el.attr('fill-opacity', 1);
            showTooltip({data:d}, el);
          })
          .on('mouseout', function (d,i) {
            const el = d3.select(this);
            el.attr('r', 3);
            el.attr('fill-opacity', 0.6);
            hideTooltip();
            //handleMouseOut(d,i);
          })
     }
    }

    function showData(data) {
      svg.innerHTML = '';
      drawForce(data);

      melodyTweet.innerHTML = `Do you think you know what this melody is? \
      <a id="melodyTweetLink" target="_blank">Tweet at us</a> and we'll \
      try to label it!`;

      if (window.innerWidth > SMALL_SCREEN_SIZE || forceLabels.checked) {
       //
      } else {
        mobileScreen.hidden = false;
      }

      melodyTweet.innerHTML += ` Or, open this melody in our \
    <a id="coucouLink" target="_blank">companion app</a> to explore more harmonizations.`
    }

    function drawForce(data) {
      const size = Math.min(Math.min(window.innerWidth, window.innerHeight), 700);
      const width = size;
      const height = size;
      const boundHeight = height - 20;
      const boundWidth = width - 20;
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);

      // If using canvas.
      // const canvas = document.querySelector('canvas');
      // canvas.setAttribute('width', width);
      // canvas.setAttribute('height', height);
      // const context = canvas.getContext('2d');
      const g = d3.select('#svg')
        .append('g')
        .attr('transform', `translate(${width / 2}, ${height/2 + 10})`);

      const cluster = d3.cluster();
      const root = cluster(data);
      const nodes = root.descendants().splice(1);
      const links = root.links();

      const link = drawSVGLinks();
      const node = drawSVGNodes();
      const simulation = d3.forceSimulation(nodes)
        //.velocityDecay(0.4)
        .force("x", d3.forceX())
        .force("y", d3.forceY())
        // space nodes apart
        .force("charge", d3.forceManyBody())
        // pull linked nodes together
        .force("link", d3.forceLink(links).distance(1).strength(1))
        // but don't overlap
        .force('collision', d3.forceCollide().radius((d) => sizeScale(d.data.count)+10))
        .on('tick', () => {
          // If using canvas.
          // context.clearRect(0, 0, width, height);
          // context.save();
          // context.translate(width / 2, height / 2);
          // links.forEach(drawCanvasLink);
          // nodes.forEach(drawCanvasNode);
          // context.restore();

          // Make sure the coordinates are in the bounding box.
          node.attr('transform', d => `translate(${getBoundedX(d)}, ${getBoundedY(d)})`);
          link
            .attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });
        });

      // If using canvas:
      // d3.select(canvas)
      //   .call(d3.drag()
      //   .container(canvas)
      //   .subject(findTarget)
      //   .on('start', dragstarted))
      // function findTarget() {
      //   return simulation.find(d3.event.x - width / 2, d3.event.y - height / 2);
      // }
      // function dragstarted() {
      //   console.log(d3.event.subject.depth + '/' + d3.event.subject.id)
      //   doClick(d3.event.subject);
      // }

      function getBoundedX(d) {
        d.x = Math.max(-boundWidth/2, Math.min(boundWidth/2, d.x));
        return d.x;
      }
      function getBoundedY(d) {
        d.y = Math.max(-boundHeight/2, Math.min(boundHeight/2, d.y));
        return d.y;
      }

      function drawSVGNodes() {
        return g.selectAll('.node')
          .data(nodes)
          .enter()
          .append('g')
            .attr('class', (d) => `node ${d.children ? 'internal' : 'leaf'}`)
          .append('circle')
          .attr('r', d => sizeScale(d.data.count))
          .attr('stroke', 'black')
          .attr('stroke-width', d => d.depth === 1 ? 2 : 0)
          .attr('fill', d => {
            if (d.id === 'root') return;
            const deltas = d.id.trim().split(' ');

            if (d.depth === 1) {
              return color(parseInt(deltas[0]));
            } else {
              return color(parseInt(deltas[deltas.length-1]));
            }
          })
          .attr('title', d => d.depth + '/' + d.id)
          .on('mouseover', handleMouseOver)
          .on('mouseout', handleMouseOut)
          .on('click', handleHackyClick)
      }
      function drawSVGLinks() {
        return g.selectAll('.link')
        .data(links)
        .enter()
          .append('line')
          .attr('class', 'link')
          .attr('stroke-width', d => d.source.id === 'root' ? 0 : 1)
          .attr('stroke', d => {
            const deltas = d.source.id.trim().split(' ');
            const delta = parseInt(deltas[deltas.length-1]);
            return delta ? color(delta) : '#ccc';
          });
      }
      function radialCoord(x,y) { return [x,y]}

      function drawCanvasLink(d) {
        if (d.source.id === 'root') return;

        const deltas = d.source.id.trim().split(' ');
        const delta = parseInt(deltas[deltas.length-1]);
        context.strokeStyle = delta ? color(delta) : '#ccc';

        context.beginPath();
        context.moveTo(d.source.x, d.source.y);
        context.lineTo(d.target.x, d.target.y);
        context.closePath();

        context.stroke();
      }

      function drawCanvasNode(d) {
        const size = sizeScale(d.data.count);
        const deltas = d.id.trim().split(' ');

        context.fillStyle = d.depth === 1 ?
            color(parseInt(deltas[0])) :
            color(parseInt(deltas[deltas.length-1]));
        if (d.depth === 1) {
          context.strokeStyle = 'black';
          context.lineWidth = 3;
        }
        context.beginPath();
        context.moveTo(getBoundedX(d) + size, getBoundedY(d));
        context.arc(getBoundedX(d), getBoundedY(d), size, 0, 2 * Math.PI);
        context.closePath();

        context.fill();
        if (d.depth === 1) context.stroke();
      }
    }

    function flattenData(data) {
      const relationships = [];
      const parentsWeKnowAbout = [];
      let minCount = 999999999, maxCount = 0;

      // We can't have multiple roots, so start this off.
      relationships.push({id:'root', parentId: ''});
      relationships.push({id:data[0].str, parentId: 'root',
          count:data[0].count, timing: data[0].timing, sessions:data[0].sessions});
      parentsWeKnowAbout.push('root');

      let parent = data[0].str;

      for (let i = 1; i < data.length; i++) {
        let parentId;
        // If this string is strictly bigger than the previous parent, since
        // we're sorted that means that's still the parent
        if (data[i].str.length > parent.length) {
          parentId = parent;
        } else {
          // The parent may have been a while back.
          const matchFound = parentsWeKnowAbout.filter(d => data[i].str.indexOf(d) == 0);
          // Since the strings are sorted, the longest match is always the best.
          parentId = matchFound.length > 0 ? matchFound[matchFound.length-1] : 'root';
        }

        relationships.push(
          {
            id: data[i].str,
            count: data[i].count,
            timing: data[i].timing,
            sessions: data[i].sessions,
            parentId: parentId
          });

        // We're the next potential parent, since again the strings are sorted.
        parent = data[i].str;
        if (parentsWeKnowAbout.indexOf(parentId) === -1) {
          parentsWeKnowAbout.push(parentId);
        }
        // If the parent is the root, we also need to add the prefixes of this
        // melody as well.

        if (data[i].count < minCount) minCount = data[i].count;
        if (data[i].count > maxCount) maxCount = data[i].count;
      }

      sizeScale = d3.scaleSqrt()
        .domain([minCount, maxCount])
        .range([4, 20]);
      return  d3.stratify()(relationships);
    }

    function doClick(d) {

      // If the tooltip is already expanded, close it (imagine someone clicked outside it).
      // otherwise, do the open dance.
      if (tooltipIsExpanded) {
        closeTooltip();
        window.location.hash = 'all'; // not the empty string so that it doesn't cause a page refresh
        return;
      }

      tooltipIsExpanded = true;

      // Expand the tooltip.
      tooltip.classList.add('expanded');
      tooltip.removeAttribute('hidden');
      btnHarmonize.disabled = false;

      let ns = getNoteSequenceFromDeltaTimingPair(d.data.timing);

      player.loadSamples(ns);
      visualizeNoteSequence(ns, 'visualizer');
    }
  </script>
</html>
